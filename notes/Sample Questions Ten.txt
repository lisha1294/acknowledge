Question (from Sample Questions Four):
What will the following program print when run using the command line: java TestClass   
public class TestClass {     
	public static void methodX() throws Exception {       
		throw new AssertionError();    
	}       
	public static void main(String[] args) {       
		try{          
			methodX();       
		} catch (Exception e) {         
			System.out.println("EXCEPTION");       
		}    
	} 
}
1. It will print EXCEPTION.
2. It will throw AssertionError out of the main method.
3. It will not compile because of the throws clause in methodX().
4. It will end without printing anything because assertions are disabled by default.

Answer:
1. The catch block will not be able to catch the Error thrown by methodX().
2. A subclass of Error cannot be caught using a catch block for Exception because java.lang.Error does not extend java.lang.Exception. 
3. The throws clause is valid even though unnecessary in this case.
4. It is true that assertions are disabled by default however, methodX is throwing an AssertionError explicitly like any other Throwable. Here, the assertion mechanism is not even used.
Correct response: 2.

Question (from sample questions four):  Will the following code compile and run?
static import java.lang.System.*;//1
class $$//2
{
	static public void main(String... _$_) //3
	{
		String _ = ""; //4
		for(int $=0; ++$ < _$_.length; ) //5
			_ += _$_[$]; //6
		out.println(_); //7
	}
}

Answer:
Everything here is valid, except the import statement, which should be import static ...
Reverse these two words and everything will compile fine.
Correct response: no.

Question:
Given the following code:
class TestClass{
   public static void main(String args[]){
      int k = 0;
      int m = 0;
      for (int i = 0; i <= 3; i++){
         k++;
         if ( i == 2){
            // line 1
         }
         m++;
      }
      System.out.println( k + ", " + m );
   }
}
What is the output if line 1 is replaces by:
1. break;
2. continue
3. i = m ++;
4. i = 4;

Answer:
This is a simple loop. All you need to do is execute each statement in your head. For example, if line 1 is replaced by break:  
1. k=0, m=0 2. 
iteration 1: i=0     
2.1 k = 1     
2.2 i == 2 is false     
2.3 m = 1 3. 
iteration 2: i = 1     
3.1 k=2     
3.2 i==2 is false     
3.3 m = 2 4. 
iteration 3: i = 2     
4.1 k=3     
4.2 i==2 is true     
4.3 break 5. 
print 3, 2
Correct answers:
1. 3, 2
2. 4, 3
3. 4, 5
4. 3, 3
(From Sample Questions Four)

Question:
Consider the following code in TestClass.java file:
package p;
private class TC extends java.util.HashMap{
   public TC(){
      super(100);
      System.out.println("TC created");
   }
}
public class TestClass extends TC{
   public TestClass(){
      System.out.println("TestClass created");
   }
   public static void main(String[] args){ new TestClass(); }
}
What will be the output when TestClass is run?

Answer:
The correct answer is that the code will not compile because TC is a top level class and private is not a valid access modifier for a top level class. private can be applied to an inner class.
Error: modifier private not allowed here.
(Four)

Question:
Which of the given lines can be inserted at //1 of the following program ?  
public class TestClass{        
	public static void main(String[] args){      
		short s = 9;      //1    
	} 
}
1. int i = 9; System.out.println(s == i);
2. Boolean b = s instanceof Number;
3. Short k = 9; Integer i = 9; System.out.println(k == i);
4. Integer i = 9; System.out.println( s == i );
5. System.out.println(s instanceof Short);
6. Short k = new Short(9); System.out.println(k instanceof Short);

Answer:
1. Any two integral primitives can be compared using == operator.
2. Left operand of instanceof MUST be an object and not a primitive.
3. This will not compile because k and i are referring to objects that have no IS-A relationship among themselves.
5. The left operand of instanceof MUST be an object and not a primitive.
6. 9 is considered an int. This should be: Short s = new Short( (short) 9 );
Correct response: 1 & 4
(4)

Question:
Consider the following lines of code:  
Integer i = new Integer(42); 
Long ln = new Long(42); 
Double d = new Double(42.0);
System.out.println(ln.equals(42));
What will be the output?

Answer:
The concept to understand here is as follows -
If the compiler can figure out that something can NEVER happen, then it flags an error. In this question, the compiler knows that ln, i or d can never point to the same object in any case because they are references to different classes of objects that have no relation ( superclass/subclass ) between themselves.
Therefore 1 and 2 will fail at compile time.
5. Due to auto-boxing int 42 is converted into an Integer object containing 42. So this is valid. It will return false though because ln is a Long and 42 is boxed into an Integer.
Correct response: false
(fOUR)

Question:
Given the following LOCs:     
int rate = 10;    
XXX amount = 1 - rate/100*1 - rate/100;  
What can XXX be?

Answer:
Note that none of the terms in the expression 1 - rate/100*1 - rate/100; is double or float. They are all ints. So the result of the expression will be an int. Since an int can be assigned to a variable of type int, long, float or double, amount cAn integer can be assigned to a double but not vice versa.

Object class's equals() method just checks whether the two references are pointing to the same location or not.

When refactoring a class to make it better in terms of encapsulation, the key is that your data variable should be private and the functionality that is to be exposed outside should be public. Further, your setter methods should be coded such that they don't leave the data members inconsistent with each other.
an be int, long, float or double.
Correct response: int, long, float or double

An integer can be assigned to a double but not vice versa.
A byte can ALWAYS be assigned to an int.
a short or byte cannot be assigned to each other unless they are cast:
		short s = 10;
		char c = s; // error
		s = c;      // error
final short s = 1; byte b = s; => This is fine because s is a constant and the value fits into a byte.
Implicit narrowing occurs only for byte, char, short, and int. Remember that it does not occur for long, float, or double. So, this will not compile: int i = 129L;

Object class's equals() method just checks whether the two references are pointing to the same location or not.

When refactoring a class to make it better in terms of encapsulation, the key is that your data variable should be private and the functionality that is to be exposed outside should be public. Further, your setter methods should be coded such that they don't leave the data members inconsistent with each other.

Question:
Which lines commented our will allow this program to compile?
interface A {
	double aMethod(int a);
}
interface B {
	double bMethod(int a, int b);
}

1. class X extendes A { double aMethod(int a);}
2. interface Y implements B { double bMethod(int x, int y);}
3. interface Z extends A { float cMethod(int a, int b);}
4. class P implements B { double aMethod(int a);}
5. abstract class Q implements A, B {
	public double aMethod(int a) {return a * a * 5.16;}
}

Answer:
Correct response: 1  2.
(from Sample Questions Five)


Question:
Cosnider these two classes: Parent.java and Child.java
package p1;
public class Parent {
	public int x = new Interger(100);
	protected int parentMethod() {
		return x;
	}
}
package p2;
import p1.Parent;
public class Child extends Parent {
	public static void main(String [] args) {
		new Child().childMethod();
	}
	void childMethod() {
		System.out.print("This "+this.parentMethod());
		Parent p = new Parent();
		System.out.prin(" parent "+p.parentMethod());
	}
}
What line can be removed to make the program compile and run?

Answer: If line 10 is removed, then the output for the program when run is: This 100
If you recall, a protected method can be called from a child class, as in line 8, but not from the parent class itself.
Correct response: System.out.prin(" parent "+p.parentMethod());
Category: Creating and Using Arrays?
Cinsider that p.parentMethod is trying to use a method thru parent, while this.parentMethod is accessing the method as the part of itself which extends parent.
What's a good family metaphore for this?  Family is allowed to access private methods.  Family being by inheritance.

<<<<<<< HEAD
Question 85:
Given the following definitions and reference declarations:

interface I1 { }
interface I2 { }
class C1 implements I1 { }
class C2 implements I2 { }
class C3 extends C1 implements I2 { }
C1 o1;
C2 o2;
C3 o3;
Which of these statements are legal?
1. class C4 extends C3 implements I1, I2 { }
2. o3 = o1;
3. o3 = o2;
4. I1 i1 = o3; I2 i2 = (I2) i1;
5. I1 b = o3;

Answer:
1. Although, the implements I1, I2 is redundant here because C3 already implements I1 and I2, it is not invalid.
2. superclass reference cannot be assigned to subclass reference without explicit cast.
3. There is no way a reference of class C2 (which is o2) can point to an object of class C3 because C2 and C3 have no inheritance relationship. So this assignment is rejected at compile time itself.
4. This is valid because at run time i1 actually refers to an object that implements I2.
5. Because C3 extends C1 which implements I1.
Correct response: 1, 4, 5.
Category: Working with Inheritance: Easy
(From Seven)

Question 86:
Consider the following code:

class A{
   A() {  print();   }
   void print() { System.out.println("A"); }
}
class B extends A{
   int i =   Math.round(3.5f);
   public static void main(String[] args){
      A a = new B();
      a.print();
   }
   void print() { System.out.println(i); }
}
What will be the output when class B is run ?

Answer:
Explanation:
Note that method print() is overridden in class B. Due to polymorphism, the method to be executed is selected depending on the class of the actual object. Here, when an object of class B is created, first A's constructor is called, which in turn calls print(). Now, since the class of actual object is B, B's print() is selected. At this point of time, variable i has not been initialized (because we are still initializing A at this point), so its default value i.e. 0 is printed. This happens because the method print() is non-private, hence polymorphic.  Finally, 4 is printed.
Correct response: It will print 0, 4
Category: Working with Inheritance: Real Brainer.
(Seven)


Question: 
Will the folliwng code print?
public class BreakTest{
  public static void main(String[] args){
    int i = 0, j = 10;
    lab1 : for( ; ; i++){
      for( ; ; --j)  if( i >j ) break lab1;
    }
    System.out.println(" i = "+i+", j = "+j);
  }
}

Answer:
Correct response: i = 0 j = -1.


Question:
Consider that str is a variable of class java.lang.String. Which of the following lines of code may throw a NullPointerException in certain situations?  Or a tougher version of the question could be : Which of the following lines of code are not an example of robust design ?
1. if ( (str != null) | ( i == str.length() ) ) 
2. if ( (str == null) | ( i == str.length() ) ) 
3. if ( (str != null) || (i == str.length() ) )
4. if ( (str == null) || (i == str.length() ) )

Answer:
(See TestClass22)
1. (i == str.length()) will always be executed so if 'str' is null, then str.length() will throw a NullPointerException.
2. (i == str.length()) will always be executed so if 'str' is null, then str.length() will throw a NullPointerException.
3. (i == str.length()) will only be evaluated if (str != null) is false, and (str != null) will be false if 'str' is null. So it will also throw a NullPointerException.
4. (i == str.length()) will only be evaluated if (str == null) is false, and (str == null) will be false if 'str' is NOT null. So it will NEVER throw a NullPointerException.
The correct answers are 1,2 and 3.
(From Sample Questions Three)

Questions:
Consider the following method:
	private static void testSampleQuestionsThree()
	{
		System.out.println('b' + new Integer(10)); // 1
		String a = 'b' + new Integer(10);		   // 2
		String s = 66 + new Integer(10);		   // 3
		System.out.println(a+" "+s);			   // 4
	}
What will be the output when compiled and run?

Answer:
There will be two compile tile errors:
At line 2 and 3: incpmpatible types
required: String
found: int
For line 1: Since the first operand of + one is of numeric type, its numberic value of 98 will be used.  Integer 10 will be unboxed and added to 98.  Therefore, the final value will be int 108.
For line 2: Since we are assinging an int to a String, we will get an error on the same code in line 1 used outside a println statement.  If both String variables are changed to int or Integer, then the output would be 108, 108 76.
