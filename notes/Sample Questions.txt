Sample Questions

Consider the following code snippet:
    arrayOfInts[j] > arrayOfInts[j+1]
Question: What operators does the code contain?
Answer: >, +

Consider the following code snippet:
int i = 10;
int n = i++%5;
    Question: What are the values of i and n after the code is executed?
    Answer: i is 11, and n is 0.
    Question: What are the final values of i and n if instead of using the postfix increment operator (i++), you use the prefix version (++i))?
    Answer: i is 11, and n is 1.

Questions and Exercises: Inheritance
1.a and c incorrect.  How do you hide an inherited method?  It's considered a bad programming practice, but the table in Overriding and Hiding Methods section shows the effect of declaring a method with the same signature as a method in the superclass.
http://docs.oracle.com/javase/tutorial/java/IandI/override.html

- What Integer method would you use to convert a string expressed in base 5 into the equivalent int? For example, how would you convert the string "230" into the integer value 65? Show the code you would use to accomplish this task.

- What Double method can you use to detect whether a floating-point number has the special value Not a Number (NaN)?

###gocertify###
1. E
int []a = {1,2,3,4,5,6};
ini i = a.length -1;
while(i>=0)
{System.out.println(a[i]);i--}
Result 654321
a len is 6. go from 5 to 0
-2. ?
3. Must extend an abstract class
4. An interface cant extend a class
An interface can extend multiple interfaces
5. Arrays are objects, so
int a[] = {1,2,3,4}
print(a instanceof Object) prints true.
-6. Indexing of array elemtns begins with zero, 43 = o53 (octal)
7. anonymous arrays.  assigned two one dimensional int arrays to the two dinmensiaonal array a.  So the code compiles and poroduces 2.
int a[][] = new int[3][];
a[1]=new int[]{1,2,3};
a[2]=new int[]{4,5};
print(a[1][1]);
-8. b,d,e
-9. e
-10. e
11. wrong pass by reference nightmare
-12
class Base
{
	int i = 99;
	public void amethod()
	{
		System.put.println("Base.amethod");
	}
	Base()
	{
		amethod();
	}
}
public class Derived extends Base
{
	int i = -1;
	public static void main(String argv[])
	{
		Base b = new Derived();
		System.out.println(b.i);
		b.amethod();
	}
	public void amethod()
	{
		System.out.println("Derived.amethod()");
	}
}
Output: 
Derived.amethod()
99
Derived.amethod()
It creates an instance of the Derived class but assigns it to a reference of the Base class.  In this situation a reference to any of the fields such as i will refer to the value in the Base class, but a call to a method will refer to the method in the class type rather than its reference handle.  But note that if the amethod() was not present in the base class, then compilation error would be reported  as at compile ime.  When the compiler sees the statement like b.amethod(), it checks if the method is present in the ase class or not.  Only at the run time it decides to call the method from the derived class.
13. 
String s = "Java";
s.concat(" SE 6");
s.replace('6','7');
print(s) // Java (the two calls are abandoned instantly)
14.
line 3, two more objects created, 'SE 6', and 'Java SE 6'
line 5 'java'
3. String s = "Java"; 1
4. s.concat(" SE 6"); 2,3
5. s.toLowerCase();   4
15

Test 2.
1-3 OK
4. 
int a = 5;
print("Value is - "+((a < 5) ? 9.9 : 9));
The result of a ternary operator must be determined at the compile time, and here the type chosen using the rules of promotion for binary operands is double.  Since the result is a double the output value is
printed in a floating point.  The choice of which value to be printed is made on the basis of the result of the comparison "a < 5" which results in false, hence the variable "a" takes the second of the two possible values, which is 9, but because the result type is promoted to double the output value is actuallu written as 9.0 rather than the more obvious 9.
5. a,c,d,e (Ouch, no d! and b is ok too..)
public class Outer {
	public int a = 1;
	privte int b = 2;
	public void method(final int c)
	{
		int d = 3;
		class inner
		{
			private void iMethod(int e)
			{
				// which variables may be referenced here?
			}
		}
	}
}
X5..  d is not final so not visible
X6. - an overriding method can allow more, but not less, access than the overridden method. Order: public, protected, (no modifier), private
7.OK

12.
x13
14.OK
15.OK
X16.
class Parent
{
	private void method1(){System.out.println("Parent1");}
	public void method2(){System.out.println("Parent2"); method1();}
}
class Child extends Parent
{
	public void method1()
	{System.out.println("Child1");}
	 public static void main(String args[])
	 {Parent p = new Child();p.method2();}
}
Output: 
Parent2
Parent1
X17.
18.IO
19.IO
20.IO

Javaprepare Mock exam 1 for SCJP 6
7:37 -17
-1.b
x2.c,g - bcf
-3.d
-4. arr.length;
x5. 0005 0x05
x6. c,f,g,h - bcfg
-7.a
-8.d
x9."amp" - am
x10.A - ac 
C. The method definitions inside interfaces are public and abstract. They cannot be private or protected.


x11.F 14 ^ 23 = ?
-12.A
x13.private - protected
x14.c,d - a,c
-15.b,c
x16.b - c
-17.a?d,e
-?18.,e
-?19.,c
-20.b,c
x21.b,d,e - bce
-22.b
-23.d
-24.a
x25.e - a
-26.b,e
x27.e - d
-28.c
-29.c,d
-30.a,c
-31.b,d
x*32.a,c - bd
?33.c - bc
-34.c collections
x35.a " - c
-36.b,c
x37.c - f
-?38.the return type of method round(double d) defined in Math class
long or float
-39.e
-40.a
*41.
x42.ArrayList
-43.a
d44.c - d
-45.b Integer.intValue()
x46.String of hex value. - int
x47.b - d
-48.a
-49.f
-50.d,c
29 out of 48 is 60%.  Not good enough.  Need to get at least 80.
