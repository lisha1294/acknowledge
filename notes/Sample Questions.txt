Sample Questions

Consider the following code snippet:
    arrayOfInts[j] > arrayOfInts[j+1]
Question: What operators does the code contain?
Answer: >, +

Consider the following code snippet:
int i = 10;
int n = i++%5;
    Question: What are the values of i and n after the code is executed?
    Answer: i is 11, and n is 0.
    Question: What are the final values of i and n if instead of using the postfix increment operator (i++), you use the prefix version (++i))?
    Answer: i is 11, and n is 1.

Questions and Exercises: Inheritance
1.a and c incorrect.  How do you hide an inherited method?  It's considered a bad programming practice, but the table in Overriding and Hiding Methods section shows the effect of declaring a method with the same signature as a method in the superclass.
http://docs.oracle.com/javase/tutorial/java/IandI/override.html

- What Integer method would you use to convert a string expressed in base 5 into the equivalent int? For example, how would you convert the string "230" into the integer value 65? Show the code you would use to accomplish this task.
String base5String = "230";
int result = Integer.valueOf(base5String, 5);
static Integer	valueOf(String s, int radix): Returns an Integer object holding the value extracted from the specified String when parsed with the radix given by the second argument.


Question: What Double method can you use to detect whether a floating-point number has the special value Not a Number (NaN)?
Answer: isNaN()

###gocertify###
1. E
int []a = {1,2,3,4,5,6};
ini i = a.length -1;
while(i>=0)
{System.out.println(a[i]);i--}
Result 654321
a len is 6. go from 5 to 0

3. Must extend an abstract class
4. An interface cant extend a class
An interface can extend multiple interfaces
5. Arrays are objects, so
int a[] = {1,2,3,4}
print(a instanceof Object) prints true.
-6. Indexing of array elemnts begins with zero, 43 = o53 (octal)
7. anonymous arrays.  assigned two one dimensional int arrays to the two dinmensiaonal array a.  So the code compiles and poroduces 2.
int a[][] = new int[3][];
a[1]=new int[]{1,2,3};
a[2]=new int[]{4,5};
print(a[1][1]); = 2

11. wrong pass by reference nightmare
-12
class Base
{
	int i = 99;
	public void amethod()
	{
		System.out.println("Base.amethod");
	}
	Base()
	{
		amethod();
	}
}
public class Derived extends Base
{
	int i = -1;
	public static void main(String argv[])
	{
		Base b = new Derived();
		System.out.println(b.i);
		b.amethod();
	}
	public void amethod()
	{
		System.out.println("Derived.amethod()");
	}
}
Output: 
Derived.amethod()
99
Derived.amethod()
It creates an instance of the Derived class but assigns it to a reference of the Base class.  In this situation a reference to any of the fields such as i will refer to the value in the Base class, but a call to a method will refer to the method in the class type rather than its reference handle.  But note that if the amethod() was not present in the base class, then compilation error would be reported at compile time.  When the compiler sees the statement like b.amethod(), it checks if the method is present in the Base class or not.  Only at the run time it decides to call the method from the derived class.
13. 
String s = "Java";
s.concat(" SE 6");
s.replace('6','7');
print(s) // Java (the two calls are abandoned instantly)
14.
line 3, two more objects created, 'SE 6', and 'Java SE 6'
line 5 'java'
3. String s = "Java"; 1
4. s.concat(" SE 6"); 2,3
5. s.toLowerCase();   4
15

Test http://www.gocertify.com/quizzes/java/scjp1/

2. Any string other than 'true' of 'false' as a Boolean constructor will result in a value of false;  Note case does not matter.
boolean a = new Boolean("tRuE"); will allocate a Boolean object representing true.

4. 
int a = 5;
print("Value is - "+((a < 5) ? 9.9 : 9));
The result of a ternary operator must be determined at compile time, and here the type chosen using the rules of promotion for binary operands is double.  Since the result is a double the output value is printed in a floating point.  The choice of which value to be printed is made on the basis of the result of the comparison "a < 5" which results in false, hence the variable "a" takes the second of the two possible values, which is 9, but because the result type is promoted to double the output value is actuallu written as 9.0 rather than the more obvious 9.
5. a,c,d,e (Ouch, no d! and b is ok too..)
public class Outer {
	public int a = 1;
	privte int b = 2;
	public void method(final int c)
	{
		int d = 3;
		class inner
		{
			private void iMethod(int e)
			{
				// which variables may be referenced here?
				// a,b,c, ,e
			}
		}
	}
}
a, b, c and e are correct. Since inner is not a static inner class, it has a reference to an enclosing object and all the variables of that object are accessible. Therefore A and B are correct even if b is private. Variables in the enclosing method are only accessible when they are marked as final, hence c is accessible but not d. E is obviously correct as it is a parameter to the method containing line 12 itself.  d is not final so not visible.

X6. - an overriding method can allow more, but not less, access than the overridden method. Order: public, protected, (no modifier), private

X16.
class Parent
{
	private void method1(){System.out.println("Parent1");}
	public void method2(){System.out.println("Parent2"); method1();}
}
class Child extends Parent
{
	public void method1()
	{System.out.println("Child1");}
	 public static void main(String args[])
	 {Parent p = new Child();p.method2();}
}
Output: 
Parent2
Parent1
If method1 in parent were not private, the output would be:
Parent2
Child1


Javaprepare Mock exam 1 for SCJP 6

x2.c,g - bcf
x5. 0005 0x05
x6. c,f,g,h - bcfg
x9."amp" - am
x10.A - ac 
C. The method definitions inside interfaces are public and abstract. They cannot be private or protected.

x11.F 14 ^ 23 = ?
x13.private - protected
x14.c,d - a,c
x16.b - c
x21.b,d,e - bce
x25.e - a
x27.e - d
x*32.a,c - bd
?33.c - bc
-34.c collections
x35.a " - c
x37.c - f
-?38.the return type of method round(double d) defined in Math class
long or float
x42.ArrayList
x46.String of hex value. - int
x47.b - d
29 out of 48 is 60%.  Not good enough.  Need to get at least 80.

PDF Questions:

Test you knowledge:
Chapter 1: Getting Started with Java p.37 (2/2)

Chapter 2: Java Data Types and Their Usage p.76 (4/6)
X1.a x c.cannot access an instance variable from a static method.
X2.a. x c,e 
float f=3.1415; float f = 3.14f;
byte b=257; byte -128 to 127 only.
OX4.a,d x a,b,d: No!  a and d only are right.  Mistake in question!

Chapter 3: Decision Constructs p.114 (5/5!)

Chapter 4: Using Arrays and Collections p.151 (1/3)
X1.a,b,c,d
Which of the following statements will compile without an error?
a. int arr[];
b. int arr[5];
c. int arr[5] = {1,2,3,4,5};
d. int arr[] = {1,2,3,4,5};
a and d The number of elements in an array declaration is not used in
the declaration. However, we can use the following:
int arr[] = new int[5];
O2.b
X3.a x 
Given the following code, which of the following statements can be used to
determine if cat can be found in the list?
ArrayList<String> list = new ArrayList<>();
list.add("dog");
list.add("cat");
list.add("frog");
a. list.contains("cat")
b. list.hasObject("cat") x
c. list.indexOf("cat")
d. list.indexOf(1)       x
a and c The contains method will return true if the object is found
and indexOf takes an object reference and returns the index
of the object if found, otherwise it returns a -1. The indexOf
method does not take an integer argument and the hasObject
method does not exist.

Chapter 5: Looping Constructs p.183 (4/5)
X1.a,c
p.179 pitfalls
Given the following declarations, which of the following statement will
compile?
int i = 5;
int j = 10;
a. while(i < j) {}
b. while(i) {}
c. while(i = 5) {}  thought it was i == 5!
d. while((i = 12)!=5) {}  // (12 != 5)
a and d The other options will not work because the expression does
not evaluate to a Boolean value.
OX2.b
Given the following declaration of an array, which statement will display
each element of the array?
int arr[] = {1,2,3,4,5};
a. for(int n : arr[]) { System.out.println(n); }
b. for(int n : arr) { System.out.println(n); }
c. for(int n=1; n < 6; n++) { System.out.println(arr[n]);
}
d. for(int n=1; n <= 5; n++) { System.out.println(arr[n]);
}
b,c,d are correct.
No, they aren't!  only b is correct. c  misses the first element, and d causes an array index out of bounds exception!

Chapter 6: Classes, Constructors, and Methods p.216 (3/7) -------
X1.b
Which of the following declares a method that takes a float and an integer and returns an array of integers?
a. public int[] someMethod(int i, float f)
{ return new int[5];}
b. public int[] someMethod(int i, float f)
{ return new int[];}
c. public int[] someMethod(int i, float f)
{ return new int[i];}
d. public int []someMethod(int i, float f)
{ return new int[5];}
a, c, and d Option b fails to initialize the array properly.


X3.b
Which of the following statements about overloaded methods are true?
a. Static methods cannot be overloaded.
b. The return value is not considered when overloading a method.
c. Private methods cannot be overloaded.
d. An overloaded method cannot throw exceptions.
a The return value is not considered when overloading a method.
(isnt that what our answer said?)
Yes, we did get this right.  b is the correct answer.

X4.a
Given the following code, which of the following statements are true?
public class SomeClass {
public SomeClass(int i, float f) { }
public SomeClass(float f, int i) { }
public SomeClass(float f) { }
public void SomeClass() { }}
a. error will occur cause void cannot be used with a constructor.
b. error will occur cause the first two constructors are not unique.
c. The class does not have a default constructor.
d. No syntax errors will be generated.
c and d The last line is a method that happens to have the same name as the constructor. As there are constructors defined but no
default constructor, the class has no default constructor.

X5.d
Which of the following keywords cannot be used when declaring a class?
a. public  OK
b. private OK
c. protected x
d. package   x
a and b Only the private and public keywords can be used when
declaring a class and the private keyword can only be used
with inner classes.

X6.a,c,d
Assuming that the following classes are in the same package, which
statements are true?
class SomeClass 
{
	void method1() { }
	public void method2( { }
	private void method3( { }
	protected void method4() { }}
	class demo 
	{
		public void someMethod(String[] parameters) 
		{
			SomeClass sc = new SomeClass();
			sc.method1();
			sc.method2();
			sc.method3(); only protected methods are not visible.
			sc.method41();}}
a. sc.method1() will generate a syntax error.
b. sc.method2() will generate a s0yntax error.
c. sc.method3() will generate a syntax error.
d. sc.method4() will generate a syntax error.
e. No syntax errors will be generated.
c As the classes are in the same package and all of the methods
are visible except for the private method.

Chapter 7: Inheritance & Polymorphism (1/6) ---------p.246
X1.c,d
Which set of statements result in ClassB and ClassC being derived
from ClassA?
a. class ClassB extends ClassA {}
b. class ClassB extends ClassC {}
c. class ClassA extends ClassB {}
d. class ClassC extends ClassB {}
e. No combination will work
a, d (second time around answer is correct!)
Answer: a and d This results in ClassC being the "grandchild" of ClassA.

X2.a,b,c?
Which of the following must be true for a method to support polymorphism?
a. The method must override a base class method
b. The method must overload a base class method
c. The method's class must extend a base class that has the
overridden method
d. The method must execute against a base class reference variable
a,c (second time around also wrong)
Answer: a and d.  Overloading only occurs within the same class. It is not necessary to have a base class. A common implemented interface will also work for polymorphic behavior.

X3.c
What method is used to determine the type of an object?
a. isType
b. typeOf
c. instanceof
d. instanceOf
a
Answer: d The other methods do not exist.
We beg to differ.  instanceof is an operator.  The method would be getClass and then use instancof?  Pretty sure they mean c., which then makes the question's use of the word 'method' wrong.

X4.a,b,c
Which of the following are valid casts?
a. num1 = num2;
b. num1 = (int)num2;
c. num1 = (float)num2;
d. num1(int) = num2;
a,b,c
Answer: b.  The others will generate syntax errors.

X5.d
Given the following class definitions:
public class ClassA 
{
	public ClassA() 
	{
		System.out.println("ClassA constructor");
	}
	public void someMethod() 
	{
		System.out.println("ClassA someMethod");
	}
}
class ClassB extends ClassA 
{
	public ClassB() 
	{
		System.out.println("ClassB constructor");
	}
	public void someMethod() 
	{
		// comment
		System.out.println("ClassB someMethod");
	}
	public static void main(String args[]) 
	{
		ClassB b = new ClassB();
		b.someMethod();
	}
}

What statement is needed at the comment line to generate the
following output:
ClassA constructor
ClassB constructor
ClassA someMethod
ClassB someMethod
a. super();
b. super().someMethod;
c. super.someMethod();
d. someMethod();
e. None of the above
c (second time lucky!)
c The first answer is used only as the first statement of a
constructor. The second answer generates a syntax error. The
fourth option results in unbounded recursion.

Chapter 8: Handling Exceptions in an Application p.275 (3/5)
x1.a,c,d
1. Which of the following implement checked exceptions?
a. Class A extends RuntimeException
b. Class A extends Throwable
c. Class A extends Exception
d. Class A extends IOException
d (second time wrong.  This time we ignored the implment part of the question)
Answer: c and d Checked exceptions are those classes that extend the Exception class but not the RuntimeException class.

X5.b,d
What exceptions may the following code generate at runtime?
String s;
int i = 5;
try{
	i = i/0;
	s += "next";
}
a. ArithmeticException
b. DivisionByZeroException
c. FileNotFoundException
d. NullPointerException
b,d
Answer: a and d DivisionByZeroException does not exist. No file
operations are performed here.

(p.297 answers)

====================

Chapter 1: Getting Started with Java p.37 (2/2)
Chapter 2: Java Data Types and Their Usage p.76 (4/6)
Chapter 3: Decision Constructs p.114 (5/5!)
Chapter 4: Using Arrays and Collections p.151 (1/3)
Chapter 5: Looping Constructs p.183 (4/5)
Chapter 6: Classes, Constructors, and Methods p.216 (3/7)
Chapter 7: Inheritance & Polymorphism (1/6) 
Chapter 8: Handling Exceptions in an Application p.275 (3/5)
23 out of 39 is 58%.  We need to score above 70% to pass, and advice said we should be scoring above 80% on mock exams before attempting the test.  
So no time to waste.



EPractize Test Product ---------

BufferedReader reader = null;      
try {         
		URL url = new URL("http://www.epractizelabs.com/serverdate.html");         
		reader = new BufferedReader(new InputStreamReader(url.openStream()));         
		String line = reader.readLine();         
		SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");         
		Date date = format.parse(line);     
	  } catch (MalformedURLException exception) 
	  {          // handle wrong URL     
	  } catch (IOException exception) 
	  {          // handle I/O errors     
	  } catch (ParseException exception) 
	  {          // handle date parse problems.     
	  } finally 
	  {          
		if (reader != null) 
		{             
			try 
			{                 
				reader.close();             
			} catch (IOException ex) 
			{                 
				ex.printStackTrace();             
			}          
		}     
	}

Question : Which of the following Java SE 7 code replaces above code?

Select one. 
Choice A: 
try {     
	BufferedReader reader = new BufferedReader(new InputStreamReader( new URL("http://www.epractizelabs.com/serverdate.html").openStream()));     
	String line = reader.readLine();     
	SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");    
	Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Choice B: (Chosen)
try (BufferedReader reader = new BufferedReader(new InputStreamReader(new URL                                                            ("http://www.epractizelabs.com/serverdate.html").openStream()))) {     String line = reader.readLine();     SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");     Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Choice C: 
try (@BufferedReader reader) {     reader = new BufferedReader(new InputStreamReader( new URL                                    ("http://www.epractizelabs.com/serverdate.html").openStream()));     String line = reader.readLine();     SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");     Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Pre Measurement  Date : 01/04/2014 
Passing score : 77%   Your score : 75%    Test status : Fail
Total No. of question(s): 16                                                   
Correct answered question(s) : 12

Objective Score
Java Basics 50%
Working With Java Data Types 33%
Using Operators and Decision Constructs 100%
Creating and Using Arrays 0%
Using Loop Constructs 100%
Working with Methods and Encapsulation 100%
Working with Inheritance 100%
Handling Exceptions 100%

Which are List objects?
- ArrayList
- LinkedList
- Vector
- Stack

What is true about local inner classes?
- It can access only final variables.

A static method can only be hidden by another static method.  A static variable may be hidden by an instance variable.

The combination of 'abstract' and 'synchronized' modifiers are not allowed.

According to the JavaBean naming standards, if the boolean property is named 'x', the accessor method is of the form boolean isX() and the mutator method is of the form void setX(boolean newValue)

variable arguments allows a method to be called with ZERO or more arguments.

A variable from an interface is by default final so cannot be changed in a subclass.
- Interfaces only describe behaviour, not state.
- they're only to be used as constants. Hence static and final. 

Class members cannot use the this keywords as there is no this to refer to.

False: Member inner classes are the static class.

Finalize will always run before an object is garbage collected.

Questions: When using the writeObject method to store (serialize) the state of an object, how can you protect sensitive data from being acessed in the stored object?
Answer: declare the sensitive fields as private transient.

Question: Which of the following keywords is used when a constructor calls an overload constructor in the same class.
Answer: this

Integer n1 = new Integer(0);
Byte n2 = new Byte((byte)0);
System.out.println(n1.equals(n2)); false!!!

- abstract classes cannot be instantiated

- super() must be the first statement in a subclass contructor.

quote(String s) returns a literal pattern string for the specified String.  This method produces a String that can be used to create a Pattern that would match the String s as if it were a literal pattern.  Meta characters or escape sequences in the input sequence will be given no special meaning.

- Number is the super class for many wrapper classes, but not Boolean and Character

- Nested (inner) classes can be declared abstract, final, private, public, or protected to restrict access to the class.

class Bank
{
	String bankName;
	public String getBranchName()
	{
		return bankName;
	}
}
public class BankBranch extends Bank
{
	public static void main(String[] argv) {}
	public String getBranchName() throws Exception 
	{
		return bankName;
	}
}
Does not compile: getBranchName() cannot override the superclass method.  The overridden method does not throw an exception.  (But it could if it were a runtime exception, right?  Or is that only checked exceptions?)

- The split() and matches() methods are present in both String and Pattern class.

- checked exceptions represent invalid conditions in areas outside the immediate control of the program.

String str = "10";
int a = new Integer(10);
boolean b = str==a;
The comparison is not legal, as only the + operator performs the implicit conversion to a String object.
ie: b = str==a+""

- if the unary operators + and - are applied to byte, char or short the types are automatically promoted to an int.

How does this code compile?
```
Number Float = 99.455f;
```
Answer, Float is not a reserved word.  'float' is.

```
boolean b = false;
boolean c = true;
if (b = c) ... true
```
The if evaluates to true because the assigment statement also has a value equal to the value being assinged.
if (b == c) ... false

Integer a = 123;
float b = 123f;
boolean c = false;
if (c|a==b) ... true!
- The a==b will be evaluated first.

boolean b=str==a; will not compile.
Incomparable types: String and Integer 

String num = "0";
num = null;
if (num instanceof Object) ... false!
- null compared with a string is not equal.

Integer number = 145; // autoboxing is ok.

Vector<String> set = new Vector<String>();
String[] arr = set.toArray();
- The toArray() method returns Object[], so to compile, the set must be cast to String.  You can fix it like this:
String[] arr = (String [])set.toArray();


The size of the array cannot be specified in the following examples:
		int i[] = new int[2] {1,2};
		int j[4] = {1,2,3,4};
The size is given implicitly by the initialization code (instance), never in the declaration of an array (reference).

void aMethod(Object ob) { //1 }
void aMethod(Float ob) {  //2 }
...
test.aMethod(0.0);  // autoboxed to Double object.

- An overriding method must not throw any checked exceptions that were not declared in the original method.

- constructors are not inherited

A a = new A();
B b = new B(); // A extends B

b=a 	x
b=(A)a; x
a=b;
a=(A)b;
a=(B)b;


class Test3
{
	public String toString() {
		return "Test3";
	}

	public static void main(String[] args) {
		Set<Test3> s = new TreeSet<Test3>();
		s.add(new Test3()); // Test3 cannot be cast to Comparable.
		s.add(new Test3());
		s.add(new Test3());
		for (Test3 out: s)
			System.out.println(out);
	}
	/**
	Either Test3 has to implement Comparable, or you need to provide a comparator when creating the TreeSet.
	 */
}
To fix this:
class Test3 implements Comparable {
 	@Override
    public int compareTo(Test3 test)
    { /* Custom test */ }

Writer w = new BufferedWriter(new FileWriter());
This will cause an IOException.
If the named file exists but is a directory rather than a file, an IOException will be thrown.
Writer w = new BufferedWriter(new FileWriter("name.txt"));
***If the file doesnt exist it will be created.***


When you call System.exit() inside a finally block, the system will exit.

Mock Exam 2

int num = -50;
System.out.println(num % 25.0)
output -0.0
We suppose that any expression containing a negative will give a negative answer, as well as follow the rules of promotion.

- j2ee-struts is not a valid identifier because it has a SLASH!!!

java Test x7+y8+z9=4P [4789][+-=]
Test class main has this expression:
System.out.println((args[0].split(args[1])).length);

- classes cannot extend interfaces, they must implement them.

- the equals() method will return false if the objects are not the same class.

String c = new String("1234567890");
StringBuffer sb = new StringBuffer(c);
- The capacity for sb is not 10+16 = 26

line 10:	Integer e;
1ine 11:	System.out.println(e); 
// compile time error at line 11, not in the previous line!

      double d_num = 999.3568;
      System.out.printf("% .2f", d_num);
Output: 999.36

      Object obj = 99;
      System.out.println(obj);
This looks odd but it compiles.  However, there would be no output.
By autoboxing, 99 int primitive value will be automatically converted to Integer object and assigned to the variable obj.

Character obj = 65;
char c = 65;
if c==obj ... TRUE

- case labels only accept constant expressions.

The so-called "hashing algorithm" implemented by class Test1 will always retrn the same value, 42, which is legal but will place all of the hash table entries into a single bucket, the most inefficient setup possible.
A **hash function** is any algorithm that maps data of arbitrary length to data of a fixed length. The values returned by a hash function are called hash values, hash codes, hash sums, checksums or simply hashes. 
- every class implicitly or explicitly provides a hashCode() method, which digests the data stored in an instance of the class into a single hash value (a 32-bit signed integer). This hash is used by other code when storing or manipulating the instance – the values are intended to be evenly distributed for varied inputs in order to use in clustering. This property is important to the performance of hash tables and other data structures that store objects in groups ("buckets") based on their computed hash values. Technically, in Java, hashCode() by default is a native method, meaning, it has the modifier 'native', as it is implemented directly in the native code in the JVM.
- a hash table (also hash map) is a data structure used to implement an associative array, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the correct value can be found.

Boolean b1 = new Boolean("TRUE");
boolean b2 = true;
if (b1==b2) // true
if (b1.equals(b2)) // true
if (b1.booleanValue()==b2) // true

		// question 20
		Integer arr[] = {2,1,0};
		print(arr);
		...
		public static void print(int...arr)
- Though Integer can be boxed into int type,
Integer[] cannot be boxed to int[], so
print(int...arr) cannot be applied to print(Integer[])

		List list2 = new ArrayList<String>();
		list2.add(new StringBuilder("123"));
This will compile because list2 is a raw type variable,
and no checking is done at compile time.

class Test {
	public void Test(String a){print(a);}
	public void Test(int b){rint(b);}
	public void Test(){print("None");}
}
Question:  What is prented when you call new Test();?
Answer: Nothing, those are not constructors because of the void return type modifier.

// question 25
int subTotal;
static int total;
public void calculate()
{
	int local;
	local = this.total; //1
	local = this.subTotal; //2
	this.total = total; //3
	//this.local = 4; Cannot find symbol
	//this = new ExamQuestions(); // 5
-  Non-static mehods have an implicit this object reference.  The this reference cannot be changed. 
- The this reference can be used in a non-static context to refer to both instance and static members.
- It cannot be used to refer to locl variables. (see 4)

- Questions 27
public class TestInterface
{
	public abstract class InnerTest
	{
		abstract void f();
	}

	public static void main(String[] args) {
		TestInterface t = new TestInterface();
		//t.f(); // cannot be found
		TestInterface.InnerTest test = t.new InnerTest()
		{
			public void f() 
			{ 
				System.out.println("Inner f");
			}
		};
		test.f(); // works fine
	}
}

- Questions 28 & 29
Protected variables or methods will not be accessable by a sub-class from their parent classes which are in different packages.  For example:

package packages;
public class Account { protected String number = "123"; }
import packages.*;
public class SilverAccount extends Account
{
	public static void main(String[] args) {
		Account gold = new Account();
		// System.out.println(gold.number); <- protected access!
		SilverAccount silver = new SilverAccount();
		System.out.println(silver.number); } // works with the subclass.	
}

- abstract methods cannot define a method body.
public abstract void method(){}
final abstract int method(){}
- both are illegal.  it should be like this:
public abstract void method();

Integer num_123 = Integer.parseInt("123L");
- this method accepts digits only and causes a runtime exception
Integer num_123 = Integer.parseInt(123L);
- compile time error: no suitable method.
parseInt(long)
Integer num_123L = Integer.parseInt(123);
- same error, no method parseInt(int)

- Question 32
static void aMethod() throws RuntimeException
{
	throw new NullPointerException(); // Exception cannot go here.
}
...
	try
	{
		aMethod();
	} catch (ClassCastException cce)
	{
		System.out.println("cce");
	} finally
	{
		System.out.println("finally");
	}


Class A {
	int a =200;
	A(int b) {
		this.a=b;
	}
}
Class Test {
	static void a1(int a) {
		a=-1;
	}
	static void a1(A a) {
	a.a=-1;
	}
	public static void main(String as[]) {
	int a=100;
	a1(a);
	A b = new A(400);
	a1(b);
	System.out.print(a+" "+b.a);
	}
}

100 -1

Mock Exam 1 Retest
Boolean string1=new Boolean("TrUe");
boolean character1=true;
assert string1.booleanValue()==character1;
assert string1==character1;
assert string1.equals(character1);
//assert !string1.booleanValue()=="true";
assert !string1.equals("true");
//assert !character1=="true";

Vector<String> set = new Vector<String>();
String[]arr=set.toArray();
toArray() returns Object[].  The return type needs to be cast to String[] to compile.
(See repeat question above for answer)

- It is possible to loop an enum with for:
enum Direction {
   NORTH,
   EAST,
   SOUTH,
   WEST
}
for (Direction dir : Direction.values()) {
  // do what you want
}

Exam 2 re-rest:

interface IAccount { String getAccoundNumber();}
abstract class Account implements IAccount{}
The class Account is valid as it is declared abstract and therefore doesn't have to implement all the methods of the superclass.

System.out.println(new Integer(0).booleanValue());
There is no such method in the Integer class.

By contract, if two objects are equivalent according to the equals() method, the  the hashCode() method must evaulate them to be ==.  
if (x3.equals(x4))
x3.hashCode() == x4.hashCode();

If a method declararation overrides a method in the super class, there will be a compile time error when:
- there are different return types
- one is void and the other has a return type
- one throws clause that conflicts with that of any other method that it overrides or hides
However, it can throw unchecked exceptions (RuntimeExceptions)  
Given this:
	public class Customer
	{
    	double calculate(int num) { /* */ }
	}
You can do this:
	double calculate(int num)
	public double calculate(int num)
	protected double calculate(int num)
	double calculate(int num) throws RuntimeException
You cannot do these:
	double calculate(int num) throws Exception
	private double calculate(int num)

Throwable
Exception
ClassNotFoundException
CloneNoteSupportedException
IllegalAccessException
IntantiationException
InterruptedException
NoSUchMethodExcption
RuntimeException

RuntimeException
ArithmethicException
ArrayStoreException
ClassCastException
IllegalArgumentException (nfe)
IllegalMonitorStateException
IndexOutOfBoundsException (aioobe)
NegativeArraySizeException
NullPointerException
SecurityException

The 'this' reference can be used in a non-static context to refer to botth instance and static members.  However, it cannot be used to refer to local variables
class Mine
{
	int subTotal;
	static int total;

	public calculate()
	{
		int local;
		// what can go here?
	}
}
valid:
local = this.total;
local = this.subTotal;
this.total = total
not valid:
this.local = 4;
- 'this' cannot be used to refer to local variables

class Test6<Ob>
{
	static Ob getOb()
	{
		// error: non-static type variable On 
		// cannot be referenced from a static
		// context.
		return null;
	}
}

Interger.parseInt("123l"); will throw a NumberFormatException as the method only accepts digits.

- review checked and unchecked errors and their heirarchy
- review how to create nested classes and their access restrictions.
- remember, abstract methods do not have a body!
abstract void f();

String str = "10";
int a = new Integer(10);
boolean b = str == a;
// incomparable types: String and int
//only the + operator performs implicit conversion to a String object.

- finalize will always run before an object is garbage collected.

- Member inner classes are the static class

- priavte synchronized int e; is an invalid class level (nonlocal) variable declaration.

class A {A() {System.out.print("Super ");}}
public class Main extends A {
    public static void main(String [] args) {
        new Main(1L).Main();
    }
    public Main(int x) {
        this();
        System.out.print(" " + (x * 2));
    }
    public Main(long x) {
        this((int) x);
        System.out.print(" " + x);
    }
    public Main() {
        super(); 
        System.out.print("No arg Sub");
    }
    void Main() {
        System.out.print(" method "); 
    }
}

- Watch out!!! You cannot assign a value to a variable declared in an interface even when the class at hand implements that interface, as all interface variables are implicitly final!