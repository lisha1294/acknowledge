Sample Questions

Consider the following code snippet:
    arrayOfInts[j] > arrayOfInts[j+1]
Question: What operators does the code contain?
Answer: >, +

Consider the following code snippet:
int i = 10;
int n = i++%5;
    Question: What are the values of i and n after the code is executed?
    Answer: i is 11, and n is 0.
    Question: What are the final values of i and n if instead of using the postfix increment operator (i++), you use the prefix version (++i))?
    Answer: i is 11, and n is 1.

Questions and Exercises: Inheritance
1.a and c incorrect.  How do you hide an inherited method?  It's considered a bad programming practice, but the table in Overriding and Hiding Methods section shows the effect of declaring a method with the same signature as a method in the superclass.
http://docs.oracle.com/javase/tutorial/java/IandI/override.html

- What Integer method would you use to convert a string expressed in base 5 into the equivalent int? For example, how would you convert the string "230" into the integer value 65? Show the code you would use to accomplish this task.
String base5String = "230";
int result = Integer.valueOf(base5String, 5);
static Integer	valueOf(String s, int radix): Returns an Integer object holding the value extracted from the specified String when parsed with the radix given by the second argument.


- What Double method can you use to detect whether a floating-point number has the special value Not a Number (NaN)?

###gocertify###
1. E
int []a = {1,2,3,4,5,6};
ini i = a.length -1;
while(i>=0)
{System.out.println(a[i]);i--}
Result 654321
a len is 6. go from 5 to 0
-2. ?
3. Must extend an abstract class
4. An interface cant extend a class
An interface can extend multiple interfaces
5. Arrays are objects, so
int a[] = {1,2,3,4}
print(a instanceof Object) prints true.
-6. Indexing of array elemnts begins with zero, 43 = o53 (octal)
7. anonymous arrays.  assigned two one dimensional int arrays to the two dinmensiaonal array a.  So the code compiles and poroduces 2.
int a[][] = new int[3][];
a[1]=new int[]{1,2,3};
a[2]=new int[]{4,5};
print(a[1][1]);
-8. b,d,e
-9. e
-10. e
11. wrong pass by reference nightmare
-12
class Base
{
	int i = 99;
	public void amethod()
	{
		System.out.println("Base.amethod");
	}
	Base()
	{
		amethod();
	}
}
public class Derived extends Base
{
	int i = -1;
	public static void main(String argv[])
	{
		Base b = new Derived();
		System.out.println(b.i);
		b.amethod();
	}
	public void amethod()
	{
		System.out.println("Derived.amethod()");
	}
}
Output: 
Derived.amethod()
99
Derived.amethod()
It creates an instance of the Derived class but assigns it to a reference of the Base class.  In this situation a reference to any of the fields such as i will refer to the value in the Base class, but a call to a method will refer to the method in the class type rather than its reference handle.  But note that if the amethod() was not present in the base class, then compilation error would be reported at compile time.  When the compiler sees the statement like b.amethod(), it checks if the method is present in the Base class or not.  Only at the run time it decides to call the method from the derived class.
13. 
String s = "Java";
s.concat(" SE 6");
s.replace('6','7');
print(s) // Java (the two calls are abandoned instantly)
14.
line 3, two more objects created, 'SE 6', and 'Java SE 6'
line 5 'java'
3. String s = "Java"; 1
4. s.concat(" SE 6"); 2,3
5. s.toLowerCase();   4
15

Test http://www.gocertify.com/quizzes/java/scjp1/

2. Any string other than 'true' of 'false' as a Boolean constructor will result in a value of false;  Note case does not matter.
boolean a = new Boolean("tRuE"); will allocate a Boolean object representing true.

4. 
int a = 5;
print("Value is - "+((a < 5) ? 9.9 : 9));
The result of a ternary operator must be determined at the compile time, and here the type chosen using the rules of promotion for binary operands is double.  Since the result is a double the output value is
printed in a floating point.  The choice of which value to be printed is made on the basis of the result of the comparison "a < 5" which results in false, hence the variable "a" takes the second of the two possible values, which is 9, but because the result type is promoted to double the output value is actuallu written as 9.0 rather than the more obvious 9.
5. a,c,d,e (Ouch, no d! and b is ok too..)
public class Outer {
	public int a = 1;
	privte int b = 2;
	public void method(final int c)
	{
		int d = 3;
		class inner
		{
			private void iMethod(int e)
			{
				// which variables may be referenced here?
			}
		}
	}
}
a, b, c and e are correct. Since inner is not a static inner class, it has a reference to an enclosing object and all the variables of that object are accessible. Therefore A and B are correct even if b is private. Variables in the enclosing method are only accessible when they are marked as final, hence c is accessible but not d. E is obviously correct as it is a parameter to the method containing line 12 itself.  d is not final so not visible.
X6. - an overriding method can allow more, but not less, access than the overridden method. Order: public, protected, (no modifier), private
7.OK

X16.
class Parent
{
	private void method1(){System.out.println("Parent1");}
	public void method2(){System.out.println("Parent2"); method1();}
}
class Child extends Parent
{
	public void method1()
	{System.out.println("Child1");}
	 public static void main(String args[])
	 {Parent p = new Child();p.method2();}
}
Output: 
Parent2
Parent1

Javaprepare Mock exam 1 for SCJP 6
7:37 -17

x2.c,g - bcf
x5. 0005 0x05
x6. c,f,g,h - bcfg
x9."amp" - am
x10.A - ac 
C. The method definitions inside interfaces are public and abstract. They cannot be private or protected.

x11.F 14 ^ 23 = ?
x13.private - protected
x14.c,d - a,c
x16.b - c
x21.b,d,e - bce
x25.e - a
x27.e - d
x*32.a,c - bd
?33.c - bc
-34.c collections
x35.a " - c
x37.c - f
-?38.the return type of method round(double d) defined in Math class
long or float
x42.ArrayList
x46.String of hex value. - int
x47.b - d
29 out of 48 is 60%.  Not good enough.  Need to get at least 80.

PDF Questions:

Test you knowledge:
Chapter 1: Getting Started with Java p.37 (2/2)

Chapter 2: Java Data Types and Their Usage p.76 (4/6)
X1.a x c.cannot access an instance variable from a static method.
X2.a. x c,e 
float f=3.1415; float f = 3.14f;
byte b=257; byte -128 to 127 only.
OX4.a,d x a,b,d: No!  a and d only are right.  Mistake in question!

Chapter 3: Decision Constructs p.114 (5/5!)

Chapter 4: Using Arrays and Collections p.151 (1/3)
X1.a,b,c,d
Which of the following statements will compile without an error?
a. int arr[];
b. int arr[5];
c. int arr[5] = {1,2,3,4,5};
d. int arr[] = {1,2,3,4,5};
a and d The number of elements in an array declaration is not used in
the declaration. However, we can use the following:
int arr[] = new int[5];
O2.b
X3.a x 
Given the following code, which of the following statements can be used to
determine if cat can be found in the list?
ArrayList<String> list = new ArrayList<>();
list.add("dog");
list.add("cat");
list.add("frog");
a. list.contains("cat")
b. list.hasObject("cat") x
c. list.indexOf("cat")
d. list.indexOf(1)       x
a and c The contains method will return true if the object is found
and indexOf takes an object reference and returns the index
of the object if found, otherwise it returns a -1. The indexOf
method does not take an integer argument and the hasObject
method does not exist.

Chapter 5: Looping Constructs p.183 (4/5)
X1.a,c
p.179 pitfalls
Given the following declarations, which of the following statement will
compile?
int i = 5;
int j = 10;
a. while(i < j) {}
b. while(i) {}
c. while(i = 5) {}  thought it was i == 5!
d. while((i = 12)!=5) {}  // (12 != 5)
a and d The other options will not work because the expression does
not evaluate to a Boolean value.
OX2.b
Given the following declaration of an array, which statement will display
each element of the array?
int arr[] = {1,2,3,4,5};
a. for(int n : arr[]) { System.out.println(n); }
b. for(int n : arr) { System.out.println(n); }
c. for(int n=1; n < 6; n++) { System.out.println(arr[n]);
}
d. for(int n=1; n <= 5; n++) { System.out.println(arr[n]);
}
b,c,d are correct.
No, they aren't!  only b is correct. c  misses the first element, and d causes an array index out of bounds exception!

Chapter 6: Classes, Constructors, and Methods p.216 (3/7) -------
X1.b
Which of the following declares a method that takes a float and an integer
returns an array of integers?
a. public int[] someMethod(int i, float f)
{ return new int[5];}
b. public int[] someMethod(int i, float f)
{ return new int[];}
c. public int[] someMethod(int i, float f)
{ return new int[i];}
d. public int []someMethod(int i, float f)
{ return new int[5];}
a, c, and d Option b fails to initialize the array properly.
But on p.151:
Which of the following statements will compile without an error?
a. int arr[];
b. int arr[5];
c. int arr[5] = {1,2,3,4,5};
d. int arr[] = {1,2,3,4,5};
a and d The number of elements in an array declaration is not used in
the declaration. However, we can use the following:
int arr[] = new int[5];
???

X3.b
Which of the following statements about overloaded methods are true?
a. Static methods cannot be overloaded.
b. The return value is not considered when overloading a method.
c. Private methods cannot be overloaded.
d. An overloaded method cannot throw exceptions.
a The return value is not considered when overloading a method.
(isnt that what our answer said?)
Yes, we did get this right.  b is the correct answer.
X4.a
Given the following code, which of the following statements are true?
public class SomeClass {
public SomeClass(int i, float f) { }
public SomeClass(float f, int i) { }
public SomeClass(float f) { }
public void SomeClass() { }}
a. error will occur cause void cannot be used with a constructor.
b. error will occur cause the first two constructors are not unique.
c. The class does not have a default constructor.
d. No syntax errors will be generated.
c and d The last line is a method that happens to have the same name
as the constructor. As there are constructors defined but no
default constructor, the class has no default constructor.
X5.d
Which of the following keywords cannot be used when declaring a class?
a. public  OK
b. private OK
c. protected x
d. package   x
a and b Only the private and public keywords can be used when
declaring a class and
X6.a,c,d
Assuming that the following classes are in the same package, which
statements are true?
class SomeClass {
void method1() { }
public void method2( { }
private void method3( { }
protected void method4() { }}
class demo {
public void someMethod(String[] parameters) {
SomeClass sc = new SomeClass();
sc.method1();
sc.method2();
sc.method3(); only protected methods are not visible.
sc.method41();}}
a. sc.method1() will generate a syntax error.
b. sc.method2() will generate a syntax error.
c. sc.method3() will generate a syntax error.
d. sc.method4() will generate a syntax error.
e. No syntax errors will be generated.
c As the classes are on the same package and all of the methods
are visible except for the private method.

Chapter 7: Inheritance & Polymorphism (1/6) ---------p.246
X1.c,d
X2.a,b,c?
X3.c
X4.a,b,c
X5.d

Chapter 8: Handling Exceptions in an Application p.275 (3/5)
x1.a,c,d
o2.b,c
O3.d
O4.a,d
X5.b,d

p.297 answers

====================

Chapter 1: Getting Started with Java p.37 (2/2)
Chapter 2: Java Data Types and Their Usage p.76 (4/6)
Chapter 3: Decision Constructs p.114 (5/5!)
Chapter 4: Using Arrays and Collections p.151 (1/3)
Chapter 5: Looping Constructs p.183 (4/5)
Chapter 6: Classes, Constructors, and Methods p.216 (3/7)
Chapter 7: Inheritance & Polymorphism (1/6) 
Chapter 8: Handling Exceptions in an Application p.275 (3/5)
23 out of 39 is 58%.  We need to score above 70% to pass, and advice said we should be scoring above 80% on mock exams before attempting the test.  
So no time to waste.



EPractize Test Product ---------

BufferedReader reader = null;      
try {         
		URL url = new URL("http://www.epractizelabs.com/serverdate.html");         reader = new BufferedReader(new InputStreamReader(url.openStream()));         String line = reader.readLine();         SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");         Date date = format.parse(line);     
	  } catch (MalformedURLException exception) 
	  {          // handle wrong URL     
	  } catch (IOException exception) 
	  {          // handle I/O errors     
	  } catch (ParseException exception) 
	  {          // handle date parse problems.     
	  } finally 
	  {          
		if (reader != null) 
		{             
			try 
			{                 
				reader.close();             
			} catch (IOException ex) 
			{                 
				ex.printStackTrace();             
			}          
		}     
	}

Question : Which of the following Java SE 7 code replaces above code?

Select one. 
Choice A: 
try {     BufferedReader reader = new BufferedReader(new InputStreamReader( new                                                          URL("http://www.epractizelabs.com/serverdate.html").openStream()));     String line = reader.readLine();     SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");     Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Choice B: (Chosen)
try (BufferedReader reader = new BufferedReader(new InputStreamReader(new URL                                                            ("http://www.epractizelabs.com/serverdate.html").openStream()))) {     String line = reader.readLine();     SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");     Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Choice C: 
try (@BufferedReader reader) {     reader = new BufferedReader(new InputStreamReader( new URL                                    ("http://www.epractizelabs.com/serverdate.html").openStream()));     String line = reader.readLine();     SimpleDateFormat format = new SimpleDateFormat("MM/DD/YY");     Date date = format.parse(line); } catch (ParseException | IOException exception) {      // handle I/O problems. } 

Pre Measurement  Date : 01/04/2014 
Passing score : 77%   Your score : 75%    Test status : Fail
Total No. of question(s): 16                                                   
Correct answered question(s) : 12

Objective Score
Java Basics 50%
Working With Java Data Types 33%
Using Operators and Decision Constructs 100%
Creating and Using Arrays 0%
Using Loop Constructs 100%
Working with Methods and Encapsulation 100%
Working with Inheritance 100%
Handling Exceptions 100%

Which are List objects?
- ArrayList
- LinkedList
- Vector
- Stack

What is true about local inner classes?
- It can access only final variables.

A static method can only be hidden by another static method.  A static variable may be hidden by an instance variable.

The combination of 'abstract' and 'synchronized' modifiers are not allowed.

According to the JavaBean naming standards, if the boolean property is named 'x', the accessor method is of the form boolean isX() and the mutator method is of the form void setX(boolean newValue)

variable arguments allows a method to be called with ZERO or more arguments.

A variable from an interface is by default final so cannot be changed in a subclass.


Class members cannot use the this keywords as there is no this to refer to.

False: Member inner classes are the static class.

Finalize will always run before an object is garbage collected.

Questions: When using the writeObject method to store the state of an object, how can you protect sensitive data from being acessed in the stored object?
Answer: declare the sensitive fields as private transient.

Question: Which of the following keyword is used when a constructor calls an overload constructor in the same class.
Answer: this

Integer n1 = new Integer(0);
Byte n2 = new Byte((byte)0);
System.out.println(n1.equals(n2)); false!!!

- abstract classes cannot be instantiated

- super() must be the first statement in a subclass contructor.

quote(String s) returns a literal patter tring for the specified String.  This method produces a String that can be used to create a Pattern that would match the String s as if it were a literal pattern.  Meta characters or escape sequences in the input sequence will be given no special meaning.

- Number is the super class for many wrapper classes, but not Boolean and Character

- Nested (inner) classes can be declared abstract or final, private, public, or protected to restrict access to the class.
class Bank
{
	String bankName;
	public String getBranchName()
	{
		return bankName;
	}
}
public class BankBranch extends Bank
{
	public static void main(String[] argv)
	{}
	public String getBranchName() throws Exception 
	{
		return bankName;
	}
}
Does not compile getBranchName() cannot over


- The split() and matches() methods are present in both String and Pattern class.

class Bank
{
	String bankName;
	public String getBranchName()
	{
		return bankName;
	}
}
public class BankBranch extends Bank
{
	public static void main(String[] argv)
	{}
	public String getBranchName() throws Exception 
	{
		return bankName;
	}
}
Does not compile getBranchName() cannot override the method in Bank.  Overridden method does not throw Exception.

- checked exceptions represent invalid conditions in areas outside the immediate control of the program.

String str = "10";
int a =new Integer(10);
boolean b = str==a;
The comparison is not legal, as only the + operator performs the implicit conversion to a String object.
ie: b = str==a+""

- if the unary operators + and - are applied to byte, char or short the types are automatically promoted to an int.

How does this code compile?
```
Number Float = 99.455f;
```
Answer, Float is not a reserved word.  'float' is.

```
boolean b = false;
boolean c = true;
if (b = c) ... true
```
The if evaluates to true because the assigment statement also has a value equal to the value being assinged.
if (b == c) ... false

Integer a = 123;
float b = 123f;
boolean c = false;
if (c|a==b) ... true!
- The a==b will be evaluated first.

boolean b=str==a; will not compile.
Incomparable types: String and Integer 

String num = "0";
num = null;
if (num instanceof Object) ... false!
null compared with a string is not equal.

Integer number = 145; // autoboxing is ok.

Vector<String> set = new Vector<String>();
String[] arr = set.toArray();
The toArray() method returns Object[], so to compile, the set must be cast to String.

The size of the array cannot be specified in the following examples:
		int i[] = new int[2] {1,2};
		int j[4] = {1,2,3,4};
The size is given implicitly by the initialization code (instance), never in the declaration of an array (reference).

void aMethod(Object ob) { //1 }
void aMethod(Float ob) {  //2 }
...
test.aMethod(0.0);  // autoboxed to Double object.

- An overriding method must not throw any checked exceptions that were not declared in the original method.

- constructors are not inherited

A a = new A();
B b = new B(); // A extends B

b=a 	x
b=(A)a; x
a=b;
a=(A)b;
a=(B)b;


class Test3
{
	public String toString() {
		return "Test3";
	}

	public static void main(String[] args) {
		Set<Test3> s = new TreeSet<Test3>();
		s.add(new Test3()); // Test3 cannot be cast to Comparable.
		s.add(new Test3());
		s.add(new Test3());
		for (Test3 out: s)
			System.out.println(out);
	}
	/**
	Either Test3 has to implement Comparable, or you need to provide a comparator when creating the TreeSet.
	 */
}


Writer w = new BufferedWriter(new FileWriter());
This will cause an IOException.
If the named file exists but is a directory rather than a file, an IOException will be thrown.
Writer w = new BufferedWriter(new FileWriter("name.txt"));
If the file doesnt exist it will be created.


When you call System.exit() inside a finally block, the system will exit.