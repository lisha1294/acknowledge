Sample Questions Four

Java Basics - Garbage Collection
Using Operators and Decision Constructs
Creating and Using Arrays


*Java Basics - Garbage Collection* -----------------

Question:
Given the following code:  
class M { } 
class N {    
	private M m = new M();    
	public void makeItNull(M pM){       
		pM = null;    
	}    
	public void makeThisNull(){       
		makeItNull(m);    
	}    
	public static void main(String[] args){       
		N n = new N();       
		n.makeThisNull();    
	} 
}  
Which of the following statements are correct?
1. There are no instances of M to be garbage collected till the program ends.
2. Setting pM = null; in makeItNull(), marks the private instance of M for garbage collection.
3. private members of a class become eligible for garbage collection only when the instance of the class itself becomes eligible for garbage collection.

Answer:
2. pM is just a method parameter (a copy of the original reference) that is passed to makeItNull(). So setting it to null will not affect the original variable.
3. This is not true. Any instance can be made eligible by setting all its references to null. For example, in the following code, the Object instance referred to by 'o', can be made eligible for garbage collection by calling setNull(), even if the instance of X itself is not eligible for garbage collection.

 class X{   
 	Object o = new Object();   
 	public void setNull(){ o = null; } 
 }  
 On the other hand, if the container object becomes eligible for GC and if there are no references to the contained objects outside of the container, the contained objects also become eligible for GC. For example, in the following code, both  - the instance of X and the object instance contained inside X, will become eligible for garbage collection:  
 ... 
 X x = new X(); 
 x = null; 
 ...
Although not mentioned explicitly in the objectives, the exam has a few basic questions on garbage collection.  All you need to know is:
1. An object can be made eligible for garbage collection by making sure there are no references pointing to that object.
2. You cannot directly invoke the garbage collector. You can suggest the JVM to perform garbage collection by calling System.gc();
Correct Answer: 1.





*Using Operators and Decision Constructs* ---------------------

Question:
What is the result of executing the following fragment of code:  boolean b1 = false; 
boolean b2 = false; 
if (b2 != b1 = !b2){    
	System.out.println("true"); 
} else{    
	System.out.println("false"); 
}

Answer:
Note that  boolean operators have more precedence than =. (In fact, = has least precedence of all operators.) so, in (b2 != b1 = !b2)  first b2 != b1 is evaluated which returns a value 'false'. So the expression becomes false = !b2. And this is illegal because false is a value and not a variable!
Had it been something like (b2 = b1 != b2) then it is valid because it will boil down to : b2 = false.  Because all an if() needs is a boolean, now b1 != b2 returns false which is a boolean and as b2 = false is an expression and every expression has a return value (which is actually the Left Hand Side of the expression). Here, it returns false, which is again a boolean.
Note that return value of expression :  i = 10 , where i is an int, is 10 (an int).
Correct response: compile time error.


*Creating and Using Arrays* --------------------------------------

Question:
Which of the following is a benefit of ArrayList over an array, true or false?
It allows you to write type safe code.

Answer:
Since ArrayList is a generics enabled class, it helps you write type safe code. For example, if you have:   ArrayList<String> al = new ArrayList<>(); al.add(new Integer(10)); will not compile because the compiler knows that al can only contain Strings.  However, this is not an advantage over an array because arrays are also type safe. For example, if you have: String[] sa = new String[10]; you cannot do sa[0] = new Integer(10); either.  But you can do Object[] oa = sa; and oa[0]  = new Integer(10); This will compile fine but will fail at runtime. This is a hole in the type safety provided by arrays.
Correct Answer: false.





