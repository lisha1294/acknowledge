Sample Questions Four

Finished to question 31.

Java Basics x 1
Working with Inheritance x 5
Working with Java Data Types - variables and Objects
Overloading Methods
Using Loop Constructs x 3
Working with methods - Access Modifiers
Java Basics - Garbage Collection
Using Operators and Decision Constructs
Creating and Using Arrays x 2

*Java Basics* ---------------------------------------------

Question:  Will the following code compile and run?
static import java.lang.System.*;//1
class $$//2
{
	static public void main(String... _$_) //3
	{
		String _ = ""; //4
		for(int $=0; ++$ < _$_.length; ) //5
			_ += _$_[$]; //6
		out.println(_); //7
	}
}

Answer:
Everything here is valid, except the import statement, which should be import static ...
Reverse these two words and everything will compile fine.
Correct response: no.

*Working with Inheritance* --------------------------------

Question:
Consider that you are writing a set of classes related to a new Data Transmission Protocol and have created your own exception hierarchy derived from java.lang.Exception as follows:
enthu.trans.ChannelException
              +-- enthu.trans.DataFloodingException, 
                    enthu.trans.FrameCollisionException
You have a TransSocket class that has the following method: 
   long connect(String ipAddr) throws ChannelException
Now, you also want to write another "AdvancedTransSocket" class, derived from "TransSocket" which overrides the above mentioned method. Which of the following are valid declaration of the overriding method?
1. int connect(String ipAddr) throws ChannelException
2. long connect(String ipAddr) throws FrameCollisionException
3. long connect(String ipAddr) throws Exception
4. long connect(String str)

Answer:
There are 2 important concepts involved here:
1. The overriding method must have same return type in case of primitives (a subclass is allowed in case of classes)  (Therefore, the choices returning int are not valid.) and the parameter list must be the same (The name of the parameter does not matter, just the Type is important). 
2. The overriding method can throw a subset of the exception or subclass of the exceptions thrown by the overridden class. Having no throws clause is also valid since an empty set is a valid subset. 
Answer 3: This option is invalid because Exception is a super class of ChannelException so it cannot be thrown by the overriding method.
Correct response: 2 and 4.

Question:
Which statements concerning the following code are true?
class A{
  public A() {} // A1
  public A(String s) {  this();  System.out.println("A :"+s);  }  // A2
}

class B extends A{
  public int B(String s) {  System.out.println("B :"+s);  return 0; } // B1
}
class C extends B{
    private C(){ super(); } // C1
    public C(String s){  this();  System.out.println("C :"+s);  } // C2
    public C(int i){} // C3
}
1. At least one of the constructors of each class is called as a result of constructing an object of class C.
2. Constructor at  //A2 will never be called in creation of an object of class C.
3. Class C can be instantiated only in two ways by users of this class.
4. //B1 will never be called in creation of objects of class A, B, or C.
5. The code will not compile. 

Answer:
Note: The C1 constructor will call A1.
1. To create any object one and only one constructor of that class and each of the super classes is called. (A constructor may delegate the construction to another constructor of the same class by calling this(...) as the first statement.)
2. Because B has no defined constructor and so a default no-argument constructor will be called, which will call the no-argument constructor of A
3. Since one constructor is private, users of this class can use only the other two public constructors from outside this class.
4. Because //B1 is not a constructor. Note that it is returning an int. A constructor does not have any return type, not even void.
Correct response: 1,2,3,4.

Question:
Which statements concerning the following code are true?

class A{
  public A() {} // A1
  public A(String s) {  this();  System.out.println("A :"+s);  }  // A2
}

class B extends A{
  public int B(String s) {  System.out.println("B :"+s);  return 0; } // B1
}
class C extends B{
    private C(){ super(); } // C1
    public C(String s){  this();  System.out.println("C :"+s);  } // C2
    public C(int i){} // C3
}
1. At least one of the constructors of each class is called as a result of constructing an object of class C.
2. Constructor at  //A2 will never be called in creation of an object of class C.
3. Class C can be instantiated only in two ways by users of this class.
4. //B1 will never be called in creation of objects of class A, B, or C.
5. The code will not compile. 

Answer:
1. To create any object one and only one constructor of that class and each of the super classes is called. (A constructor may delegate the construction to another constructor of the same class by calling this(...) as the first statement.)
2. Because B has no defined constructor and so a default no-argument constructor will be called, which will call the no-argument constructor of A
3. Since one constructor is private, users of this class can use only the other two public constructors from outside this class.
4. //B1 will never be called in creation of objects of class A, B, or C.
Correct response:

Question: Which of the following statements are correct?
1. An interface can be extended by an abstract class.
2. An interface can be extended by a concrete class.
3. An abstract class cannot implement an interface.
Answer:
1. A class "implements" an interface. It does not "extend" an interface.
3. Any class, whether abstract or concrete, can implement any interface.
Correct response: 1, 2, and 3 are all wrong.


*Working with Java Data Types - variables and Objects* ----

Question: What will the output of the following be?
		byte b = (byte)128;
		System.out.println(b);

Answer:
Since the range of a byte is -128 to 127, the cast is necessary to compile and run.  The byte will clock around to the start, which is -128.
The same answer will come from a value of 384.
256 = 0.


*Overloading Methods* -------------------------------------

Question:
Consider the following code:
public class Varargs{
   public void test(){
        test1(10);       //1
        test1(10, 20); //2
   }
   public static void main(String[] args){
     new Varargs().test();
   }
   //insert method here.
}
Which of the following lines can be added independently to the above class so that it will run without any errors or exceptions?
1. public void test1(int i, int j){}
2. public void test1(int i, int... j){}
3. public void test1(int... i){}
4. public void test1(int i...){}
5. public void test1(int[] i){}

Answer:
Even though a var-arg parameter of type int is very similar to int[], they are not interchangeable. Therefore, int[] cannot be substituted for int... and it will not satisfy either of //1 or //2.
An interesting observation is that if you do javap on the following class, you will see the same signature for method m1 and m2. This shows that a var-arg parameter of type T is same as an array of type T.
class TestClass {
    String m1(int[] i) { return ""+i.length; }
    String m2(int... i) { return ""+i.length; }
}
javap TestClass produces this:

    java.lang.String m1(int[]);
    java.lang.String m2(int[]);
Conversely, the following code will not compile:
class TestClass {
    String m1(int[] i) { return ""+i.length; }
    String m1(int... i) { return ""+i.length; }  // Compiler determines that this is a duplicate method.
}
Correct response: 2 & 3.


*Using Loop Constructs* ------------------------------

Question: 
Will the folliwng code print?
public class BreakTest{
  public static void main(String[] args){
    int i = 0, j = 5;
    lab1 : for( ; ; i++){
      for( ; ; --j)  if( i >j ) break lab1;
    }
    System.out.println(" i = "+i+", j = "+j);
  }
}

Answer:
The values of i and j in the inner most for loop change as follows: 
i = 0 j = 5 
i = 0 j = 4 
i = 0 j = 3 
i = 0 j = 2 
i = 0 j = 1 
i = 0 j = 0 
i = 0 j = -1
Note: for ( ; ; --j) actually compiles!
So will for( ; ; )!

Question:
Consider the following code:  
public class Conversion{    
	public static void main(String[] args){      
		int i = 1234567890;      
		float f = i;      
		System.out.println(i - (int)f);    
	} 
}  
What will it print when run?

Answer:
Actually it prints -46. This is because the information was lost during the conversion from type int to type float as values of type float are not precise to nine significant digits. Note: You are not required to know the number of significant digits that can be stored by a float for the exam. However, it is good to know about loss of precision while using float and double.
float f = i;   // f = 1.23456794E9

Question:
Given the following code:
class TestClass{
   public static void main(String args[]){
      int k = 0;
      int m = 0;
      for (int i = 0; i <= 3; i++){
         k++;
         if ( i == 2){
            // line 1
         }
         m++;
      }
      System.out.println( k + ", " + m );
   }
}
What is the output if line 1 is replaces by:
1. break;
2. continue
3. i = m ++;
4. i = 4;

Answer:
This is a simple loop. All you need to do is execute each statement in your head. For example, if line 1 is replaced by break:  
1. k=0, m=0 2. 
iteration 1: i=0     
2.1 k = 1     
2.2 i == 2 is false     
2.3 m = 1 3. 
iteration 2: i = 1     
3.1 k=2     
3.2 i==2 is false     
3.3 m = 2 4. 
iteration 3: i = 2     
4.1 k=3     
4.2 i==2 is true     
4.3 break 5. 
print 3, 2
Correct answers:
1. 3, 2
2. 4, 3
3. 4, 5
4. 3, 3


*Working with methos - Access Modifiers* -------------

Question:
Consider the following code in TestClass.java file:
package p;
private class TC extends java.util.HashMap{
   public TC(){
      super(100);
      System.out.println("TC created");
   }
}
public class TestClass extends TC{
   public TestClass(){
      System.out.println("TestClass created");
   }
   public static void main(String[] args){ new TestClass(); }
}
What will be the output when TestClass is run?

Answer:
The correct answer is that the code will not compile because TC is a top level class and private is not a valid access modifier for a top level class. private can be applied to an inner class.
Error: modifier private not allowed here.


*Java Basics - Garbage Collection* -----------------

Question:
Given the following code:  
class M { } 
class N {    
	private M m = new M();    
	public void makeItNull(M pM){       
		pM = null;    
	}    
	public void makeThisNull(){       
		makeItNull(m);    
	}    
	public static void main(String[] args){       
		N n = new N();       
		n.makeThisNull();    
	} 
}  
Which of the following statements are correct?
1. There are no instances of M to be garbage collected till the program ends.
2. Setting pM = null; in makeItNull(), marks the private instance of M for garbage collection.
3. private members of a class become eligible for garbage collection only when the instance of the class itself becomes eligible for garbage collection.

Answer:
2. pM is just a method parameter (a copy of the original reference) that is passed to makeItNull(). So setting it to null will not affect the original variable.
3. This is not true. Any instance can be made eligible by setting all its references to null. For example, in the following code, the Object instance referred to by 'o', can be made eligible for garbage collection by calling setNull(), even if the instance of X itself is not eligible for garbage collection.

 class X{   
 	Object o = new Object();   
 	public void setNull(){ o = null; } 
 }  
 On the other hand, if the container object becomes eligible for GC and if there are no references to the contained objects outside of the container, the contained objects also become eligible for GC. For example, in the following code, both  - the instance of X and the object instance contained inside X, will become eligible for garbage collection:  
 ... 
 X x = new X(); 
 x = null; 
 ...
Although not mentioned explicitly in the objectives, the exam has a few basic questions on garbage collection.  All you need to know is:
1. An object can be made eligible for garbage collection by making sure there are no references pointing to that object.
2. You cannot directly invoke the garbage collector. You can suggest the JVM to perform garbage collection by calling System.gc();
Correct Answer: 1.


*Using Operators and Decision Constructs* ---------------------

Question:
Assume that a, b, and c refer to instances of primitive wrapper classes. Which of the following statements are correct?
1. a.equals(a) will always return true.
2. a.equals(b) returns same as a == b.
3. a.equals(b) returns false if they refer to instances of different classes.

Answer:
2. The wrapper classes's equals() method overrides Object's equals() method to compare the actual value instead of the reference.
Equals method of a primitive wrapper class ( e.g. java.lang.Integer, Double, Float etc) are 1. symmetric => a.equals(b) returns same as b.equals(a) 2. transitive => if a.equals(b) and b.equals(c) return true, then a.equals(c) returns true. 3. reflexive => a.equals(a) return true.  For example, the following code for the equals method on Integer explains how it works: public boolean equals(Object obj) {    if (obj instanceof Integer) {        return value == ((Integer)obj).intValue();    }    return false; }
Correct response: 1 & 3.


Question:
Consider the following lines of code:  
Integer i = new Integer(42); 
Long ln = new Long(42); 
Double d = new Double(42.0);  
Which of the following options are valid?
i == ln; // 1
ln == d; // 2
i.equals(d); // 3
d.equals(ln); // 4
ln.equals(42); // 5

Answer:
The concept to understand here is as follows -
If the compiler can figure out that something can NEVER happen, then it flags an error. In this question, the compiler knows that ln, i or d can never point to the same object in any case because they are references to different classes of objects that have no relation ( superclass/subclass ) between themselves.
Therefore 1 and 2 will fail at compile time.
5. Due to auto-boxing int 42 is converted into an Integer object containing 42. So this is valid. It will return false though because ln is a Long and 42 is boxed into an Integer.
Correct response: 3, 4, 5.

Question:
What is the result of executing the following fragment of code:  boolean b1 = false; 
boolean b2 = false; 
if (b2 != b1 = !b2){    
	System.out.println("true"); 
} else{    
	System.out.println("false"); 
}

Answer:
Note that  boolean operators have more precedence than =. (In fact, = has least precedence of all operators.) so, in (b2 != b1 = !b2)  first b2 != b1 is evaluated which returns a value 'false'. So the expression becomes false = !b2. And this is illegal because false is a value and not a variable!
Had it been something like (b2 = b1 != b2) then it is valid because it will boil down to : b2 = false.  Because all an if() needs is a boolean, now b1 != b2 returns false which is a boolean and as b2 = false is an expression and every expression has a return value (which is actually the Left Hand Side of the expression). Here, it returns false, which is again a boolean.
Note that return value of expression :  i = 10 , where i is an int, is 10 (an int).
Correct response: compile time error.


*Creating and Using Arrays* --------------------------------------

Question:
What will be the result when the following code is run?
class Test26 {
	public static int[ ] getArray() {return null;}
	public static void main(String[] args) {
		int index = 1;
		try {
			getArray()[index=2]++;
		} catch (Exception e){ } //empty catch
		System.out.println("index = " + index);
	}
}

Answer:
If the array reference expression produces null instead of a reference to an array, then a NullPointerException is thrown at runtime, but only after all parts of the array reference expression have been evaluated and only if these evaluations completed normally. 

This means, first index = 2 will be executed, which assigns 2 to index. After that null[2] is executed, which throws a NullPointerException. But this exception is caught by the catch block, which prints nothing. So it seems like NullPointerException is not thrown but it actually is.

In other words, the embedded assignment of 2 to index occurs before the check for array reference produced by getArray().

In an array access, the expression to the left of the brackets appears to be fully evaluated before any part of the expression within the brackets is evaluated. Note that if evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated.

Question:
Which of the following is a benefit of ArrayList over an array, true or false?
It allows you to write type safe code.

Answer:
Since ArrayList is a generics enabled class, it helps you write type safe code. For example, if you have:   ArrayList<String> al = new ArrayList<>(); al.add(new Integer(10)); will not compile because the compiler knows that al can only contain Strings.  However, this is not an advantage over an array because arrays are also type safe. For example, if you have: String[] sa = new String[10]; you cannot do sa[0] = new Integer(10); either.  But you can do Object[] oa = sa; and oa[0]  = new Integer(10); This will compile fine but will fail at runtime. This is a hole in the type safety provided by arrays.
Correct Answer: false.



